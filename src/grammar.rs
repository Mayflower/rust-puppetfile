// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use std::char;
use std::str;
use super::*;
use semver::VersionReq;
use semver;
use self::RuleResult::{Matched, Failed};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> { Matched(usize, T), Failed, }
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter)
     -> ::std::result::Result<(), ::std::fmt::Error> {
        try!(write ! (
             fmt , "error at {}:{}: expected " , self . line , self . column
             ));
        if self.expected.len() == 0 {
            try!(write ! ( fmt , "EOF" ));
        } else if self.expected.len() == 1 {
            try!(write ! (
                 fmt , "`{}`" , escape_default (
                 self . expected . iter (  ) . next (  ) . unwrap (  ) ) ));
        } else {
            let mut iter = self.expected.iter();
            try!(write ! (
                 fmt , "one of `{}`" , escape_default (
                 iter . next (  ) . unwrap (  ) ) ));
            for elem in iter {
                try!(write ! ( fmt , ", `{}`" , escape_default ( elem ) ));
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str { "parse error" }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn slice_eq_case_insensitive(input: &str, state: &mut ParseState, pos: usize,
                             m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() ||
               input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize)
 -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let mut remaining = pos;
    let mut lineno: usize = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
struct ParseState<'input> {
    max_err_pos: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl <'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),
                   _phantom: ::std::marker::PhantomData,}
    }
    fn mark_failure(&mut self, pos: usize, expected: &'static str)
     -> RuleResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn parse_parse<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<Puppetfile> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_forge(input, state, pos);
                        match seq_res {
                            Matched(pos, forge) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_modules(input,
                                                                  state, pos);
                                                match seq_res {
                                                    Matched(pos, modules) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        Puppetfile{forge:
                                                                                       forge,
                                                                                   modules:
                                                                                       modules,}
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_forge<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "forge");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_string(input, state, pos);
                                    match seq_res {
                                        Matched(pos, url) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos, { url })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_modules<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<Vec<Module>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res = parse_module(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, repeat_value)
    }
}
fn parse_module<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<Module> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "mod");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_string(input, state, pos);
                                    match seq_res {
                                        Matched(pos, name) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match {
                                                                          let seq_res =
                                                                              slice_eq(input,
                                                                                       state,
                                                                                       pos,
                                                                                       ",");
                                                                          match seq_res
                                                                              {
                                                                              Matched(pos,
                                                                                      _)
                                                                              =>
                                                                              {
                                                                                  parse___(input,
                                                                                           state,
                                                                                           pos)
                                                                              }
                                                                              Failed
                                                                              =>
                                                                              Failed,
                                                                          }
                                                                      } {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_module_info(input,
                                                                                              state,
                                                                                              pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    info)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    &input[start_pos..pos];
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            Module{name:
                                                                                                                       name,
                                                                                                                   info:
                                                                                                                       info,}
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_module_info<'input>(input: &'input str,
                             state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<Vec<ModuleInfo>> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ",");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse___(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res =
                            {
                                let choice_res =
                                    parse_version(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_info_hash(input, state, pos),
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, i) => {
                    {
                        let match_str = &input[start_pos..pos];
                        Matched(pos, { i })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_version<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<ModuleInfo> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_string(input, state, pos);
            match seq_res {
                Matched(pos, version) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                if semver::Version::parse(&version).is_ok()
                                                   {
                                                    ModuleInfo::Version(VersionReq::parse(&format!("={}"
                                                                                                   ,
                                                                                                   version)).unwrap())
                                                } else {
                                                    ModuleInfo::Version(VersionReq::parse(&version).unwrap())
                                                }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_info_hash<'input>(input: &'input str, state: &mut ParseState<'input>,
                           pos: usize) -> RuleResult<ModuleInfo> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_symbol(input, state, pos);
            match seq_res {
                Matched(pos, key) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "=>");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_string(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        value)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                ModuleInfo::Info(key,
                                                                                                                 value)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_symbol<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, ":");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_identifier(input, state, pos);
                        match seq_res {
                            Matched(pos, i) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_letter(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         state,
                                                                         pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                state,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "_"),
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, chars) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { chars })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, string) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { string })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            s.into_iter().collect()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, state,
                                                            pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState<'input>,
                                             pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\"");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match_str.chars().next().unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\'");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\'");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            s.into_iter().collect()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, state,
                                                            pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState<'input>,
                                             pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\'");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                match_str.chars().next().unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simpleEscapeSequence<'input>(input: &'input str,
                                      state: &mut ParseState<'input>,
                                      pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    slice_eq(input, state,
                                                             pos, "x");
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_eolChar(input,
                                                                          state,
                                                                          pos),
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = any_char(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    &input[start_pos..pos];
                                                Matched(pos,
                                                        {
                                                            match match_str.chars().nth(1).unwrap()
                                                                {
                                                                'n' => '\n',
                                                                'r' => '\r',
                                                                't' => '\t',
                                                                x => x,
                                                            }
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_zeroEscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState<'input>,
                                    pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\0");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    parse_digit(input, state, pos);
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { 0u8 as char })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hexEscapeSequence<'input>(input: &'input str,
                                   state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\x");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                &input[start_pos..pos];
                                                            Matched(pos,
                                                                    {
                                                                        u32::from_str_radix(match_str,
                                                                                            16)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_unicodeEscapeSequence<'input>(input: &'input str,
                                       state: &mut ParseState<'input>,
                                       pos: usize) -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\u");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        &input[start_pos..pos];
                                                                                    Matched(pos,
                                                                                            {
                                                                                                u32::from_str_radix(match_str,
                                                                                                                    16)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eolEscapeSequence<'input>(input: &'input str,
                                   state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_eol(input, state, pos);
                        match seq_res {
                            Matched(pos, eol) => {
                                {
                                    let match_str = &input[start_pos..pos];
                                    Matched(pos, { '\n' })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_digit<'input>(input: &'input str, state: &mut ParseState<'input>,
                       pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '0' ...'9' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9]"),
        }
    } else { state.mark_failure(pos, "[0-9]") }
}
fn parse_hexDigit<'input>(input: &'input str, state: &mut ParseState<'input>,
                          pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '0' ...'9' | 'a' ...'f' | 'A' ...'F' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9a-fA-F]"),
        }
    } else { state.mark_failure(pos, "[0-9a-fA-F]") }
}
fn parse_letter<'input>(input: &'input str, state: &mut ParseState<'input>,
                        pos: usize) -> RuleResult<()> {
    {
        let choice_res = parse_lowerCaseLetter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_upperCaseLetter(input, state, pos),
        }
    }
}
fn parse_lowerCaseLetter<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            'a' ...'z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[a-z]"),
        }
    } else { state.mark_failure(pos, "[a-z]") }
}
fn parse_upperCaseLetter<'input>(input: &'input str,
                                 state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            'A' ...'Z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[A-Z]"),
        }
    } else { state.mark_failure(pos, "[A-Z]") }
}
fn parse___<'input>(input: &'input str, state: &mut ParseState<'input>,
                    pos: usize) -> RuleResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_eol(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_comment(input, state, pos),
                            }
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_comment<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "#");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, state, pos);
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_eol<'input>(input: &'input str, state: &mut ParseState<'input>,
                     pos: usize) -> RuleResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u{2028}");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u{2029}"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar<'input>(input: &'input str, state: &mut ParseState<'input>,
                         pos: usize) -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched(next, ()),
            _ => state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]"),
        }
    } else { state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]") }
}
fn parse_whitespace<'input>(input: &'input str,
                            state: &mut ParseState<'input>, pos: usize)
 -> RuleResult<()> {
    if input.len() > pos {
        let (ch, next) = char_range_at(input, pos);
        match ch {
            ' ' | '\t' | '\u{a0}' | '\u{feff}' | '\u{1680}' | '\u{180e}' |
            '\u{2000}' ...'\u{200a}' | '\u{202f}' | '\u{205f}' | '\u{3000}' =>
            Matched(next, ()),
            _ =>
            state.mark_failure(pos,
                               "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]"),
        }
    } else {
        state.mark_failure(pos,
                           "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]")
    }
}
pub fn parse<'input>(input: &'input str) -> ParseResult<Puppetfile> {
    let mut state = ParseState::new();
    match parse_parse(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let (line, col) = pos_to_line(input, state.max_err_pos);
    Err(ParseError{line: line,
                   column: col,
                   offset: state.max_err_pos,
                   expected: state.expected,})
}
